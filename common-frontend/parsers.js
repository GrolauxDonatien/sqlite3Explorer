let parsers = (function () {

    let operatorFrom = { "=": "==", "AND": "&&", "OR": "||", "NOT": "!" };
    let operatorTo = { "==": "=", "&&": " AND ", "||": " OR ", "!": "NOT " };
    const _ASTERISKS_ = "EVERYTHING";

    function clearObject(o) {
        for (let k in o) delete o[k];
    }

    function $extend() {
        let tgt = arguments[0];
        for (let i = arguments.length - 1; i > 0; i--) {
            for (let k in arguments[i]) {
                if (arguments[i][k]) tgt[k] = arguments[i][k];
            }
        }
        return tgt;
    }

    /*
    * Bit of an explanation for why this transform function exists:
    * This application uses 3 differents models to represent a SQL query: 1. text string, 2. simple JSON which maps to the query builder UI, 3. proper parse tree
    * Depending on the situation, the code uses the model better suited for the task at hand. While this approach is far from optimal from a performance perspective 
    * (the same parse tree may be generated several times unnecessarily), I believe it makes for a simpler and clearer code. As queries are rather limited in size, the
    * performance is not a problem even using this unoptimized approach.
    * As for the parse tree, it is first generated using js-sql-parser, and then its notation is changed by using this transform function. At first, this project started as
    * a proof of concept to be integrated in another project. In this other project, it would have made sense to be able to express conditions using JavaScript syntax instead
    * of SQL syntax. This is quite similar to what linq does for C#, but keeping the SQL syntax for the remaining of the query. For that reason, the SQL parse tree is converted
    * to the syntax of the JavaScript parse tree generated by jsep. Along the development, I realized that some SQL constructs do not have a JavaScript equivalent.
    * Maybe a solution could be found for some (count(distinct *) => countDistinct(STAR) for example), but subqueries using mixed syntax would not make it: 
    * if only boolean expressions use JavaScript syntax, how do you express a partly SQL syntax-based subquery in a condition ?
    * That's when I dropped the support for this mixed syntax and only support pure SQL syntax. However, in the meantime, a lot of the code was now relying on the jsep parser syntax
    * internally. As the code is working, and the performance is not bad to the point it needs to be optimized, this unnecessary transformation of the parse tree stays.
    * Sorry for this mess !
    */
    function transform(input, key) {
        let tree = input[key];
        let sub, args;
        switch (tree.type) {
            case "ComparisonBooleanPrimary":
                tree.type = "BinaryExpression";
                if (tree.operator in operatorFrom) tree.operator = operatorFrom[tree.operator];
                transform(tree, "left");
                transform(tree, "right");
                break;
            case "Identifier":
                let split = tree.value.split('"');
                let ref;
                if (split.length == 1) {
                    tree.computed = false;
                    ref = split[0];
                } else {
                    tree.computed = true;
                    ref = split.join('');
                }
                split = ref.split('.');
                if (split.length == 2) {
                    tree.type = "MemberExpression";
                    delete tree.value;
                    tree.object = { type: "Identifier", name: split[0] };
                    tree.property = { type: "Identifier", name: split[1] };
                } else {
                    delete tree.computed;
                    tree.name = tree.value;
                    delete tree.value;
                }
                break;
            case "AndExpression":
            case "OrExpression":
                tree.type = "LogicalExpression";
                if (tree.operator in operatorFrom) tree.operator = operatorFrom[tree.operator];
                transform(tree, "left");
                transform(tree, "right");
                break;
            case "XORExpression":
                transform(tree, "left");
                transform(tree, "right")
                sub = {
                    type: "CallExpression",
                    arguments: [tree.left, tree.right],
                    calles: { type: "Identifier", name: "xor" }
                }
                clearObject(tree);
                $extend(tree, sub);
                break;
            case "BitExpression":
                transform(tree, "left");
                transform(tree, "right")
                if (RegExp('^[A-Za-z]+$').test(tree.operator)) {
                    sub = {
                        type: "CallExpression",
                        arguments: [tree.left, tree.right],
                        calles: { type: "Identifier", name: tree.operator.toLowerCase() }
                    }
                    clearObject(tree);
                    $extend(tree, sub);
                } else {
                    tree.type = "BinaryExpression";
                }
                break;
            case "FunctionCall":
                tree.type = "CallExpression";
                tree.callee = { type: 'Identifier', name: tree.name };
                if (tree.params) {
                    for (let i = 0; i < tree.params.length; i++) {
                        if (tree.params[i].distinctOpt == "DISTINCT") {
                            tree.distinct = true;
                            break;
                        }
                    }
                }
                delete tree.name;
                tree.arguments = [];
                for (let i = 0; i < tree.params.length; i++) {
                    transform(tree.params, i);
                    tree.arguments.push(tree.params[i]);
                }
                delete tree.params;
                break;
            case "FunctionCallParam":
                transform(tree, "value");
                let v = tree.value;
                for (let k in tree) delete tree[k];
                $extend(tree, v);
                break;
            case "BooleanExtra":
                tree.type = "Literal";
                tree.raw = tree.value;
                tree.value = tree.value.toLowerCase() == "true";
                break;
            case "Number":
                tree.type = "Literal";
                tree.raw = tree.value;
                tree.value = parseFloat(tree.value);
                break;
            case "String":
                tree.type = "Literal";
                tree.raw = tree.value;
                tree.value = tree.value.substring(1, tree.value.length - 2);
                break;
            case "SimpleExprParentheses":
                input[key] = tree.value.value[0]; // replaces by the content of the parentheses
                transform(input, key);
                break;
            case "Null":
                tree.type = "Literal";
                tree.raw = tree.value;
                tree.value = null;
                break;
            case "IsNullBooleanPrimary":
                tree.type = "BinaryExpression";
                tree.operator = (tree.hasNot == null ? "==" : "!=");
                delete tree.hasNot;
                tree.right = { type: "Literal", value: null, raw: "null" };
                tree.left = tree.value;
                delete tree.value;
                transform(tree, "left");
                break;
            case "LikePredicate":
                transform(tree, "left");
                transform(tree, "right")
                sub = {
                    type: "CallExpression",
                    arguments: [tree.left, tree.right],
                    calles: { type: "Identifier", name: "like" }
                }
                if (tree.type.hasNot === null) {
                    clearObject(tree);
                    $extend(tree, sub);
                } else {
                    clearObject(tree);
                    $extend(tree, {
                        type: "UnaryExpression",
                        operator: "!",
                        argument: sub,
                        prefix: true
                    });
                }
                break;
            case "InExpressionListPredicate":
                transform(tree, "left")
                args = [tree.left];
                for (let i = 0; i < tree.right.value.length; i++) {
                    transform(tree.right.value, i)
                    args.push(tree.right.value[i]);
                }
                sub = {
                    type: "CallExpression",
                    arguments: args,
                    calles: { type: "Identifier", name: "in" }
                }
                if (tree.type.hasNot === null) {
                    clearObject(tree);
                    $extend(tree, sub);
                } else {
                    clearObject(tree);
                    $extend(tree, {
                        type: "UnaryExpression",
                        operator: "!",
                        argument: sub,
                        prefix: true
                    });
                }
                break;
            case "BetweenPredicate":
                transform(tree, "left")
                transform(tree.right, "left");
                transform(tree.right, "right");
                sub = {
                    type: "CallExpression",
                    arguments: [tree.left, tree.right.left, tree.right.right],
                    calles: { type: "Identifier", name: "between" }
                }
                if (tree.type.hasNot === null) {
                    clearObject(tree);
                    $extend(tree, sub);
                } else {
                    clearObject(tree);
                    $extend(tree, {
                        type: "UnaryExpression",
                        operator: "!",
                        argument: sub,
                        prefix: true
                    });
                }
                break;
            case "RegexpPredicate":
                transform(tree, "left");
                transform(tree, "right")
                sub = {
                    "type": "CallExpression",
                    "arguments": [tree.right],
                    "callee": {
                        "type": "MemberExpression",
                        "computed": false,
                        "object": {
                            "type": "CallExpression",
                            "arguments": [tree.left],
                            "callee": {
                                "type": "Identifier",
                                "name": "RegExp"
                            }
                        },
                        "property": {
                            "type": "Identifier",
                            "name": "test"
                        }
                    }
                }
                if (tree.type.hasNot === null) {
                    clearObject(tree);
                    $extend(tree, sub);
                } else {
                    clearObject(tree);
                    $extend(tree, {
                        type: "UnaryExpression",
                        operator: "!",
                        argument: sub,
                        prefix: true
                    });
                }
                break;
            case "InSubQueryPredicate":
                transform(tree, "left");
                transform(tree, "right")
                break;
            case "Select":
                if (tree.selectItems.value) {
                    for (let i = 0; i < tree.selectItems.value.length; i++) {
                        transform(tree.selectItems.value, i);
                    }
                }
                if (tree.where) {
                    transform(tree, "where");
                }
                if (tree.having) {
                    transform(tree, "having");
                }
                break;
            case "SubQuery":
                transform(tree, "value");
                break;
            case "NotExpression":
                transform(tree, "value");
                break;
            case "Boolean":
                tree.type = "Literal";
                tree.raw = tree.value;
                tree.value = tree.value.toLowerCase() == "true";
                break;
            case "ComparisonSubQueryBooleanPrimary":
            case "SoundsLikePredicate":
            default:
                if (tree == "*") {
                    input[key] = { type: "Identifier", name: _ASTERISKS_ };
                } else {
                    debugger;
                    throw new Error(tree.type + " is not supported");
                }
        }
    }

    function parseSelect(select) {
        let all = parsers.sqlParser.parse("SELECT " + select + " FROM fake");
        transform(all.value.selectItems.value, 0);
        return all.value.selectItems.value[0];
    }

    function parseWhere(where, subqueries) {
        for (let k in subqueries) {
            let idx = where.indexOf(k);
            if (idx != -1) {
                where = where.substring(0, idx) + "SELECT * FROM " + k + where.substring(idx + k.length);
            }
        }
        let all = parsers.sqlParser.parse("SELECT * FROM fake WHERE " + where);
        function loop(r) {
            if (typeof r == "string" || typeof r == "number") return;
            if (r.type == "SubQuery" && r.value.selectItems.value.length == 1
                && ((r.value.selectItems.value[0].type == "SelectExpr" && r.value.selectItems.value[0].value.length == 1 && r.value.selectItems.value[0].value[0].type == "Identifier" && r.value.selectItems.value[0].value[0].name == "*")
                    || (r.value.selectItems.value[0].type == "Identifier" && r.value.selectItems.value[0].value == "*")
                ) && r.value.from.type == "TableReferences" && r.value.from.value.length == 1
                && r.value.from.value[0].type == "TableReference" && r.value.from.value[0].value.type == "TableFactor" && r.value.from.value[0].value.value.type == "Identifier"
                && r.value.from.value[0].value.value.value in subqueries) {
                r.name = r.value.from.value[0].value.value.value;
            } else {
                if ("value" in r) { loop(r.value) };
                if ("left" in r) { loop(r.left) };
                if ("right" in r) { loop(r.right) };
            }
        }
        if (subqueries) loop(all.value.where);
        transform(all.value, "where");
        return all.value.where;
    }

    function processCondition(cond) {
        let subqueryid = 0;
        let subqueries = {};
        let existsqueries = {};
        let identifiers = {};
        function process(input, key) {
            let tree = input[key];
            switch (tree.type) {
                case "AndExpression":
                case "OrExpression":
                case "XORExpression":
                case "ComparisonBooleanPrimary":
                case "BitExpression":
                case "LikePredicate":
                case "RegexpPredicate":
                case "InExpressionListPredicate":
                    process(tree, "left");
                    process(tree, "right");
                    break;
                case "Identifier":
                    let split = tree.value.split('"');
                    let ref;
                    if (split.length == 1) {
                        ref = split[0];
                    } else {
                        ref = split.join('');
                    }
                    split = ref.split('.');
                    if (split.length == 2) {
                        if (!(split[0] in identifiers)) identifiers[split[0]] = {}
                        identifiers[split[0]][split[1]] = tree.value;
                    } else {
                        if (!("" in identifiers)) identifiers[""] = {}
                        identifiers[""][split[1]] = tree.value;
                    }
                    break;
                case "FunctionCall":
                    for (let i = 0; i < tree.params.length; i++) {
                        process(tree.params, i);
                    }
                    break;
                case "FunctionCallParam":
                    process(tree, "value");
                    break;
                case "Null":
                case "String":
                case "Number":
                case "BooleanExtra":
                case "Boolean":
                    break;
                case "SimpleExprParentheses":
                    process(tree.value.value, 0);
                    break;
                case "IsNullBooleanPrimary":
                case "NotExpression":
                    process(tree, "value");
                    break;
                case "BetweenPredicate":
                    process(tree, "left")
                    process(tree.right, "left");
                    process(tree.right, "right");
                    break;
                case "Select":
                    let sub = parsers.sqlParser.stringify({ type: "Main", value: tree }).trim();
                    let id = "____SUB_QUERY____" + subqueryid;
                    subqueryid++;
                    subqueries[id] = sub;
                    for (let k in tree) delete tree[k];
                    tree.type = "Identifier";
                    tree.value = id;
                    break;
                case "InSubQueryPredicate":
                    tree.type = "InExpressionListPredicate";
                    process(tree, "left");
                    process(tree, "right");
                    break;
                case "SubQuery":
                    process(tree, "value");
                    existsqueries[tree.value.value] = subqueries[tree.value.value];
                    tree.type = tree.value.type;
                    tree.value = "(" + tree.value.value + ")";
                    if (tree.hasNot == "NOT") {
                        tree.value = "NOT " + tree.value;
                    }
                    if (tree.hasExists === true) {
                        tree.value = "EXISTS " + tree.value;
                    }
                    break;
                case "ComparisonSubQueryBooleanPrimary":
                case "SoundsLikePredicate":                // TODO
                default:
                    if (tree != "*") {
                        debugger;
                        throw new Error(tree.type + " is not supported");
                    }
            }
        }
        let all = parsers.sqlParser.parse("SELECT * FROM fake WHERE " + cond);
        process(all.value, "where");

        let dummy = parsers.sqlParser.parse("SELECT * FROM T WHERE TRUE");
        dummy.value.where = all.value.where;
        return {
            identifiers,
            subqueries,
            existsqueries,
            preformat: parsers.sqlParser.stringify(dummy).substring(23)
        }

    }

    function transformFrom(froms) {
        let ret = [];
        for (let i = 0; i < froms.length; i++) {
            let table = froms[i].value.value.value;
            let alias;
            if (froms[i].value.alias === null) {
                alias = table;
            } else {
                alias = froms[i].value.alias.value;
            }
            ret.push({ [alias]: table });
        }
        return ret;
    }

    function parseFrom(from) {
        let all = parsers.sqlParser.parse("SELECT * FROM " + from);
        return transformFrom(all.value.from.value);
    }

    function parseFroms(froms) {
        let ret = [];
        let dummy;
        function loop(what) {
            let jointype;
            switch (what.type) {
                case "TableReferences":
                    for (let i = 0; i < what.value.length; i++) {
                        if (ret.length > 0) {
                            ret.push({});
                        }
                        loop(what.value[i]);
                    }
                    break;
                case "TableReference":
                    loop(what.value);
                    break;
                case "TableFactor":
                    dummy = parsers.sqlParser.parse("SELECT * FROM T");
                    dummy.value.from.value[0].value = what;
                    let s = parsers.sqlParser.stringify(dummy).substring(15).split(" ");
                    if (s.length == 1) {
                        ret.push({ table: s[0] });
                    } else {
                        ret.push({
                            alias: s[s.length - 1],
                            table: s.slice(0, s.length - 1).join(" ")
                        });
                    }
                    break;
                /* those go together */
                case "InnerCrossJoinTable":
                    jointype = "inner";
                case "LeftRightJoinTable":
                    if (jointype === undefined) jointype = what.leftRight.toLowerCase();
                case "InnerCrossJoinTable":
                    if (jointype === undefined) jointype = "outer";
                    loop(what.left);
                    if (what.condition != null) {
                        dummy = parsers.sqlParser.parse("SELECT * FROM T WHERE TRUE");
                        dummy.value.where = what.condition.value;
                        ret.push({ [jointype]: parsers.sqlParser.stringify(dummy).substring(22) });
                    } else {
                        ret.push({ [jointype]: null });
                    }
                    loop(what.right);
                    break;
                default:
                    debugger;
                    throw new Error("Cannot process from");
            }
        }
        loop(froms);
        return ret;
    }

    function parse(query) {
        let all = parsers.sqlParser.parse(query);
        let select = [];
        let dummy = parsers.sqlParser.parse("SELECT TRUE");
        if (all.value.selectItems != null) for (let i = 0; i < all.value.selectItems.value.length; i++) {
            dummy.value.selectItems.value[0] = all.value.selectItems.value[i];
            select.push(parsers.sqlParser.stringify(dummy).substring(8));
        }
        let groupby = [];
        if (all.value.groupBy != null) for (let i = 0; i < all.value.groupBy.value.length; i++) {
            dummy.value.selectItems.value[0] = all.value.groupBy.value[i].value;
            groupby.push(parsers.sqlParser.stringify(dummy).substring(8));
        }
        let orderby = [];
        if (all.value.orderBy != null) for (let i = 0; i < all.value.orderBy.value.length; i++) {
            dummy.value.selectItems.value[0] = all.value.orderBy.value[i].value;
            orderby.push(parsers.sqlParser.stringify(dummy).substring(8) + " " + (all.value.orderBy.value[i].sortOpt || "ASC"));
        }
        let where = "";
        if (all.value.where !== null) {
            dummy = parsers.sqlParser.parse("SELECT * FROM T WHERE TRUE");
            dummy.value.where = all.value.where;
            where = parsers.sqlParser.stringify(dummy).substring(23);
        }
        let having = "";
        if (all.value.having !== null) {
            dummy = parsers.sqlParser.parse("SELECT * FROM T WHERE TRUE");
            dummy.value.where = all.value.having;
            having = parsers.sqlParser.stringify(dummy).substring(23);
        }
        let from = [];
        if (all.value.from !== undefined) {
            from = parseFroms(all.value.from);
        }

        return {
            "select": select,
            "distinct": all.value.distinctOpt !== null,
            "from": from,
            "where": where,
            "groupby": groupby,
            "having": having,
            "orderby": orderby
        }
    }

    function stringify(model) {
        let txt;
        let sep = " ";
        txt = "SELECT";
        if (model.distinct === true) sep = " DISTINCT ";
        for (let i = 0; i < model.select.length; i++) {
            txt += sep + model.select[i];
            sep = ",";
        }
        if ("from" in model && model.from.length > 0) {

            function toString(from) {
                return parsers.getTableAliasName(from).name;
            }

            txt += " FROM " + toString(model.from[0]);
            let i = 1;
            while (i < model.from.length) {
                if ("inner" in model.from[i]) {
                    txt += " INNER JOIN " + toString(model.from[i + 1]) + " ON " + model.from[i].inner;
                } else if ("left" in model.from[i]) {
                    txt += " LEFT JOIN " + toString(model.from[i + 1]) + " ON " + model.from[i].left;
                } else if ("right" in model.from[i]) {
                    txt += " RIGHT JOIN " + toString(model.from[i + 1]) + " ON " + model.from[i].right;
                } else if ("full" in model.from[i]) {
                    txt += " FULL JOIN " + toString(model.from[i + 1]) + " ON " + model.from[i].full;
                } else {
                    txt += ", " + toString(model.from[i + 1]);
                }
                i += 2;
            }
        }
        if ("where" in model && model.where.trim() != "") {
            txt += " WHERE " + model.where;
        }
        if ("groupby" in model && model.groupby.length > 0) {
            txt += " GROUP BY ";
            sep = "";
            for (let i = 0; i < model.groupby.length; i++) {
                txt += sep + model.groupby[i];
                sep = ",";
            }
            if ("having" in model && model.having.trim() != "") {
                txt += " HAVING " + model.having;
            }
        }
        if ("orderby" in model && model.orderby.length > 0) {
            txt += " ORDER BY ";
            sep = "";
            for (let i = 0; i < model.orderby.length; i++) {
                txt += sep + model.orderby[i];
                sep = ",";
            }
        }
        return txt;
    }

    function stringifyTree(tree) {
        function parse(w) {
            if (w && w.type) {
                if (!(w.type in parser)) {
                    console.info(parsers);
                    return "";
                }
                let ret = parser[w.type](w);
                if (("hasAs" in w) && w.hasAs === true) {
                    ret += " AS " + w.alias;
                }
                return ret;
            }
            return "";
        }
        let parser = {
            BinaryExpression(t) {
                if (t.operator == "==" && t.right.type == "Literal" && t.right.raw == "null") {
                    return parse(t.left) + " IS NULL";
                }
                if (t.operator == "!=" && t.right.type == "Literal" && t.right.raw == "null") {
                    return parse(t.left) + " IS NOT NULL";
                }
                let o = [];
                function add(s, withParentheses) {
                    if (withParentheses && (s.type == 'BinaryExpression' || s.type == 'LogicalExpression')) {
                        o.push("(" + parse(s) + ")");
                    } else {
                        o.push(parse(s));
                    }
                }
                add(t.left, t.operator != '&&');
                if (t.operator in operatorTo) {
                    o.push(operatorTo[t.operator]);
                } else {
                    o.push(t.operator);
                }
                add(t.right, t.operator != '&&');
                return o.join('');
            },
            LogicalExpression(t) {
                return parser.BinaryExpression(t);
            },
            MemberExpression(t) {
                if (t.computed) {
                    return parse(t.object) + '."' + parse(t.property) + '"';
                } else {
                    return parse(t.object) + "." + parse(t.property);
                }
            },
            Identifier(t) {
                return t.name == _ASTERISKS_ ? "*" : t.name;
            },
            ThisExpression(t) {
                return "this";
            },
            CallExpression(t) {
                // TODO: xor, in, like
                let o = [parse(t.callee)];
                o.push('(');
                if (t.distinct === true) o.push('DISTINCT ');
                for (let i = 0; i < t.arguments.length; i++) {
                    if (i > 0) o.push(",");
                    o.push(parse(t.arguments[i]));
                }
                o.push(')');
                return o.join('');
            },
            Literal(t) {
                return t.raw;
            },
            UnaryExpression(t) {
                if (t.prefix) {
                    return t.operator + parse(t.argument);
                } else {
                    return parse(t.argument) + t.operator;
                }
            },
            ArrayExpression(t) {
                let o = [];
                o.push('[');
                for (let i = 0; i < t.elements.length; i++) {
                    if (i > 0) o.push(',');
                    o.push(parse(t.elements[i]));
                }
                o.push(']');
                return o.join('');
            },
            Compound(t) {
                let o = [];
                for (let i = 0; i < t.body.length; i++) {
                    o.push(parse(t.body[i]));
                }
                return o.join('');
            },
            InSubQueryPredicate(t) {
                return parse(t.left) + (t.hasNot == "NOT" ? " NOT IN " : " IN ") + "(" + parse(t.right) + ")";
            },
            SubQuery(t) {
                return (t.hasExists === true ? "EXISTS " : "") + "(" + parse(t.value) + ")";
            },
            Select(t) {
                let items = t.selectItems.value;
                let selects = [];
                if (items) for (let i = 0; i < items.length; i++) {
                    selects.push(parse(items[i]));
                }
                t.selectItems.value = [{ type: "Identifier", value: selects.join(", ") }];
                if (t.where) t.where = { type: 'Identifier', value: parse(t.where) };
                if (t.having) t.having = { type: 'Identifier', value: parse(t.having) };
                return parsers.sqlParser.stringify({ nodeType: 'Main', hasSemicolon: false, value: t })
            },
            NotExpression(t) {
                return "NOT " + parse(t.value);
            }
        }
        return parse(tree);
    }

    function extend() {
        let ret = arguments[0];
        for (let i = 1; i < arguments.length; i++) {
            for (let k in arguments[i]) {
                ret[k] = arguments[i][k];
            }
        }
        return ret;
    }


    function getTableAliasName(from) {
        return {
            alias: ("alias" in from ? from.alias : from.table),
            table: from.table,
            name: (("alias" in from && from.alias != from.table) ? (from.table + " " + from.alias) : from.table)
        }
    }


    function disAmbiguateSelect(model, schema) {
        let newModel = extend({}, model);
        let dis = {};
        let bad = {};
        for (let i = 0; i < newModel.from.length; i += 2) {
            let from = getTableAliasName(newModel.from[i]);
            if (from.table in schema) {
                for (let k in schema[from.table]) {
                    if (k == "coords___") continue;
                    if (k in dis) {
                        bad[k] = true;
                    } else {
                        dis[k] = from.alias + "." + k;
                    }
                }
            }
        }
        for (let k in bad) {
            delete dis[k];
        }
        function disAmbiguate(tree) {
            switch (tree.type) {
                case "Identifier":
                    if (tree.name in dis) {
                        tree.type = "MemberExpression";
                        let full = dis[tree.name].split(".");
                        delete tree.name;
                        tree.object = { type: "Identifier", name: full[0] };
                        tree.property = { type: "Identifier", name: full[1] };
                    }
                    break;
                case "CallExpression":
                    tree.callee.name = tree.callee.name.toUpperCase();
                    for (let i = 0; i < tree.arguments.length; i++) {
                        disAmbiguate(tree.arguments[i]);
                    }
                    break;
            }
            if ("left" in tree) {
                disAmbiguate(tree.left);
            }
            if ("right" in tree) {
                disAmbiguate(tree.right);
            }
        }
        for (let i = 0; i < newModel.select.length; i++) {
            let temp = parsers.parseSelect(newModel.select[i]);
            disAmbiguate(temp);
            newModel.select[i] = parsers.stringifyTree(temp);
        }
        for (let i = 1; i < newModel.from.length; i += 2) {
            let k = Object.keys(newModel.from[i]);
            if (k.length > 0) {
                let temp = parsers.parseWhere(newModel.from[i][k[0]]);
                disAmbiguate(temp);
                newModel.from[i][k[0]] = parsers.stringifyTree(temp);
            }
        }
        if (("where" in newModel) && newModel.where.trim() != "") {
            let temp = parsers.parseWhere(newModel.where);
            disAmbiguate(temp);
            newModel.where = parsers.stringifyTree(temp);
        }
        for (let i = 0; i < newModel.groupby.length; i++) {
            let temp = parsers.parseSelect(newModel.groupby[i]);
            disAmbiguate(temp);
            newModel.groupby[i] = parsers.stringifyTree(temp);
        }
        if (("having" in newModel) && newModel.having.trim() != "") {
            let temp = parsers.parseWhere(newModel.having);
            disAmbiguate(temp);
            newModel.having = parsers.stringifyTree(temp);
        }
        for (let i = 0; i < newModel.orderby.length; i++) {
            let direction = "ASC";
            let item = newModel.orderby[i].trim();
            if (item.toUpperCase().endsWith(" ASC")) {
                item = item.substring(0, item.length - 4).trim();
            } else if (item.toUpperCase().endsWith(" DESC")) {
                direction = "DESC";
                item = item.substring(0, item.length - 5).trim();
            }
            if (item in dis) {
                item = dis[item];
            }
            newModel.orderby[i] = item + " " + direction;
        }
        for (let k in model) {
            delete model[k];
        }
        for (let i = 0; i < newModel.from.length; i++) {
            let k = Object.keys(newModel.from[i]);
            if (k.length == 0) continue;
            let cond = newModel.from[i][k[0]];
            let p = parsers.processCondition(cond);
            let subs = Object.keys(p.subqueries);
            if (subs.length > 0) {
                console.log(p);
            }
        }

        if (newModel.where) {
            let p = parsers.processCondition(newModel.where);
            let subs = Object.keys(p.subqueries);
            if (subs.length > 0) {
                for (let i = 0; i < subs.length; i++) {
                    p.subqueries[subs[i]] = disAmbiguateSelect(parsers.parse(p.subqueries[subs[i]]), schema);
                }
                let r = p.preformat;
                for (let i = 0; i < subs.length; i++) {
                    r = r.replace(subs[i], parsers.stringify(p.subqueries[subs[i]]));
                }
                newModel.where = r;
            }
        }


        extend(model, newModel);
        return model;
    }


    return {
        parseSelect,
        parseWhere,
        parseFrom,
        parse,
        stringify,
        stringifyTree,
        processCondition,
        extend,
        getTableAliasName,
        disAmbiguateSelect,
        setSQLParser(parser) {
            parsers.sqlParser = {
                stringify: parser.stringify,
                parse(query) {
                    // this dance is to fix a problem where the parser does not support setting AS columns properly
                    let p = window.dbadapter.prepSelect(query);
                    let ret = parser.parse(p.query);
                    window.dbadapter.setAlias(ret, p.map);
                    return ret;
                }
            }
        }
    }
})();

if (typeof window != 'undefined') window.parsers = parsers;
if (typeof module != 'undefined' && module.exports) module.exports = { parsers };
